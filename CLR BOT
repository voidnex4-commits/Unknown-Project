# bot.py — Combined "Pure Gold" bot (discord.py 2.x)
# Includes: slash commands + prefix commands, polls, session commands, server override/unlock,
# promote, stafffeedback, welcome messages, master pause/resume, logging, uptime pinger,
# and message command `clr!codedelete` (shuts the bot down).
#
# Requirements:
#   pip install -U "discord.py[voice]" aiohttp
#
# Use environment variable DISCORD_TOKEN for token, or set TOKEN below.

import asyncio
import os
import sys
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional

import aiohttp
import discord
from discord import app_commands
from discord.ext import commands, tasks

# ---------- Logging ----------
logging.basicConfig(level=logging.INFO)
log = logging.getLogger("clr-bot")

# ---------- CONFIG (IDs from your snippets) ----------
TOKEN = os.environ.get("DISCORD_TOKEN")
CLIENT_ID = 1404061937427284059
GUILD_ID = 1377700771683893309

PROMOTION_PERMS_ROLE_ID = 1377701385759494264
ALT_ROLE_ID = 1377701319053283379            # your ALT role constant (user provided)
ALT_ROLE_LOCK = 1377701315576201308          # earlier you asked to lock sessions to this role (SLT?) - keep both
STAFF_PROMOTION_EMOJI_ID = 1396581359635402994
FEEDBACK_CHANNEL_ID = 1377729734011781130

ADMIN_OVERRIDE_ROLE_ID = 1404202577100279960
ADMIN_ROLE_IDS = [
  1377701325592072283,1377701323092263045,1377701322480156702,1378352155236368455,
  1377701326280069171,1403084480624984094,1403069817258377267,1377701320873738380,
  1377701315576201308,1377701317757243472,1377701317308448888,1377701316322787399,
  1403070430528667658,1391803171638218902,1399082073955766485,1377724116232310846,
  1377701315328868382,1377701319053283379,1403070756996386816,1377701314188021760,
  1377701313621524550,1377701307296518208,1378476527838038031,1404067925819658332
]

OVERRIDE_CHANNEL_IDS = [
  1377721062229545122, 1377724833881653288, 1377989178964316320, 1378005074193809591
]
OVERRIDE_LOG_CHANNEL_ID = 1404196505816006797
OVERRIDE_IMAGE_URL = "https://media.discordapp.net/attachments/1389640286485086349/1404205575952269386/New_York_Roleplay_Professional.png"

POLL_GIF_URL = "https://media.discordapp.net/attachments/1377729047701753956/1399782056527138847/CLR_SMALLER_BANNER.gif"
THUMBNAIL_URL = "https://media.discordapp.net/attachments/1389640286485086349/1404110742113751121/CLR_BG_LOGO.webp"

SLT_ROLE_ID = 1377701315576201308
STAFF_SHOUT_ROLE_ID = 1378018500269838378

# SESSION images and channel/role lock
SESSION_CHANNEL_ID = 1378021872188522646  # session embeds must go only to this channel
SESSION_IMAGES = {
  "vote": "https://media.discordapp.net/attachments/1389640286485086349/1404449842801021019/SESSION_VOTE_1.png",
  "start": "https://media.discordapp.net/attachments/1389640286485086349/1404450143247532032/SESSION_START.png",
  "low": "https://media.discordapp.net/attachments/1389640286485086349/1404450813426008104/SESSION_START_1.png",
  "full": "https://media.discordapp.net/attachments/1389640286485086349/1404451195262599322/SESSION_FULL.png",
  "shutdown": "https://media.discordapp.net/attachments/1389640286485086349/1404451563896045618/SESSION_SHUTDOWN.png"
}
OWNERSHIP_EMOJI_ID = STAFF_PROMOTION_EMOJI_ID

# Master user + trigger phrase
MASTER_USER_ID = 1299998109543301172
TRIGGER_PHRASE = "pulled an all nighter js for the bot @CLR | Staff Utilities#5388 you better thank me"

# Cooldowns
COOLDOWN_TEST_SECONDS = 300  # 5 minutes

# ---------- Bot setup ----------
intents = discord.Intents.default()
intents.guilds = True
intents.members = True
intents.messages = True
intents.message_content = True

# We'll support both prefix commands and slash commands
BOT_PREFIX = "clr!"
bot = commands.Bot(command_prefix=BOT_PREFIX, intents=intents, application_id=CLIENT_ID)

# In-memory stores
removed_roles_store: Dict[int, List[int]] = {}
channel_perms_store: Dict[int, Dict[str, str]] = {}
active_polls: Dict[str, dict] = {}
is_paused = False
cooldowns: Dict[int, float] = {}

# ---------- Helper: create session embeds ----------
def make_session_embeds(hoster_avatar_url: str, hoster_username: str) -> Dict[str, discord.Embed]:
    ownership = f"<:OWNERSHIP:{OWNERSHIP_EMOJI_ID}>"
    vote = discord.Embed(title=f"{ownership} SESSION VOTE", description="Session Vote!\nVote for a session and let's get this underway!\n5 Votes are required!", color=0xFFD966)
    vote.set_author(name=hoster_username, icon_url=hoster_avatar_url)
    vote.set_image(url=SESSION_IMAGES["vote"])
    vote.set_footer(text="Vote count required: 5")

    start = discord.Embed(title=f"{ownership} SESSION START UP!", description="A session has been started!\nPlease join up and show us some support!\nIf you have voted for the session,\nand have failed to join, you will be moderated!\nServer Code: `ukclr`", color=0x55FF55)
    start.set_author(name=hoster_username, icon_url=hoster_avatar_url)
    start.set_image(url=SESSION_IMAGES["start"])

    low = discord.Embed(title=f"{ownership} SESSION LOW", description="Join up for some peak roleplays!\nIn-Game Code: `ukclr`", color=0xFFDD99)
    low.set_author(name=hoster_username, icon_url=hoster_avatar_url)
    low.set_image(url=SESSION_IMAGES["low"])

    full = discord.Embed(title=f"{ownership} SESSION FULL", description="Thank you so much for the support, CLR!\nIf you cannot join, there should be a short queue!", color=0x99CCFF)
    full.set_author(name=hoster_username, icon_url=hoster_avatar_url)
    full.set_image(url=SESSION_IMAGES["full"])

    shutdown = discord.Embed(title=f"{ownership} SESSION SHUT-DOWN", description="The session has shut!\nPlease leave with effect, or you will be moderated!\nThank you for joining Central London Roleplay.", color=0xFF6666)
    shutdown.set_author(name=hoster_username, icon_url=hoster_avatar_url)
    shutdown.set_image(url=SESSION_IMAGES["shutdown"])

    return {"vote": vote, "start": start, "low": low, "full": full, "shutdown": shutdown}

# ---------- Helper: log commands to override log channel ----------
async def log_command(user: discord.User, command_name: str, channel_id: Optional[int], extra: str = "—"):
    try:
        ch = bot.get_channel(OVERRIDE_LOG_CHANNEL_ID) or await bot.fetch_channel(OVERRIDE_LOG_CHANNEL_ID)
        if ch and isinstance(ch, discord.TextChannel):
            embed = discord.Embed(title="Command Executed", color=0x00AAFF, timestamp=datetime.utcnow())
            embed.add_field(name="Command", value=str(command_name), inline=True)
            embed.add_field(name="User", value=f"{user} ({user.id})", inline=True)
            embed.add_field(name="Channel", value=f"<#{channel_id}>" if channel_id else "DM", inline=True)
            embed.add_field(name="Extra", value=str(extra), inline=False)
            await ch.send(embed=embed)
    except Exception as e:
        log.exception("log_command failed: %s", e)

# ---------- Events ----------
@bot.event
async def on_ready():
    log.info(f"Logged in as {bot.user} (id: {bot.user.id})")
    # Sync commands to guild for quicker testing
    try:
        guild = discord.Object(id=GUILD_ID)
        await bot.tree.sync(guild=guild)
        log.info("Synced app commands to guild.")
    except Exception:
        try:
            await bot.tree.sync()
            log.info("Synced global app commands.")
        except Exception as e:
            log.exception("Failed to sync app commands: %s", e)
    if not uptime_ping.is_running():
        uptime_ping.start()

@bot.event
async def on_member_join(member: discord.Member):
    try:
        welcome_embed = discord.Embed(color=0xADD8E6)
        welcome_embed.set_thumbnail(url=THUMBNAIL_URL)
        welcome_embed.title = "WELCOME!"
        welcome_embed.description = f"WELCOME!\nWelcome {member.user.name} to {member.guild.name}! We hope you enjoy your stay here! Check our <#1377719482352402523> for more information!"
        welcome_embed.set_image(url=POLL_GIF_URL)
        welcome_embed.set_footer(text=f"Member Count: {member.guild.member_count}")
        ch = member.guild.get_channel(1377724833881653288) or await member.guild.fetch_channel(1377724833881653288)
        if ch:
            await ch.send(embed=welcome_embed)
    except Exception as e:
        log.exception("error in on_member_join: %s", e)

# ---------- MESSAGE HANDLER (master phrase + clr!esd/clr!stu + clr!codedelete) ----------
@bot.event
async def on_message(message: discord.Message):
    global is_paused
    if message.author.bot:
        return

    content = (message.content or "").strip()

    # clr!codedelete -> shut down (MASTER only)
    if content == "clr!codedelete":
        if message.author.id != MASTER_USER_ID:
            await message.channel.send("You do not have permission to run clr!codedelete.")
            return
        await message.channel.send("Shutting down the bot as requested... goodbye.")
        try:
            # log to override channel
            await log_command(message.author, "clr!codedelete", message.channel.id, "bot shutdown initiated")
        except:
            pass
        # close bot gracefully
        await bot.close()
        # ensure process exit
        try:
            sys.exit(0)
        except SystemExit:
            os._exit(0)
        return

    # clr!esd (pause) / clr!stu (resume)
    if content == "clr!esd":
        if message.author.id != MASTER_USER_ID:
            await message.channel.send("You do not have permission to pause the bot.")
            return
        if is_paused:
            await message.channel.send("Bot is already paused.")
            return
        is_paused = True
        await message.channel.send("Bot is now paused. Slash commands and polls are disabled for non-master users.")
        await log_command(message.author, "clr!esd", message.channel.id, "bot paused")
        return

    if content == "clr!stu":
        if message.author.id != MASTER_USER_ID:
            await message.channel.send("You do not have permission to resume the bot.")
            return
        if not is_paused:
            await message.channel.send("Bot is not paused.")
            return
        is_paused = False
        await message.channel.send("Bot has resumed normal operation.")
        await log_command(message.author, "clr!stu", message.channel.id, "bot resumed")
        return

    # Master trigger phrase (case-insensitive)
    if TRIGGER_PHRASE.lower() in content.lower():
        if message.author.id == MASTER_USER_ID:
            await message.channel.send("thank you master")
        else:
            await message.channel.send(f"you are not my master, <@{MASTER_USER_ID}>")
        return

    # Let commands process (prefix commands)
    await bot.process_commands(message)

# ---------- PREFIX COMMANDS (for convenience; mirror slash functionality) ----------
@bot.command(name="promote")
@commands.has_role(PROMOTION_PERMS_ROLE_ID)
async def cmd_promote(ctx: commands.Context, user: discord.Member, old_role: discord.Role, new_role: discord.Role, *, reason: str):
    """Promote a staff member (prefix)."""
    if is_paused and ctx.author.id != MASTER_USER_ID:
        return await ctx.reply("Bot is paused.")
    try:
        if old_role not in user.roles:
            return await ctx.reply(f"User does not have old role {old_role.mention}.")
        # try remove/add
        await user.remove_roles(old_role)
        await user.add_roles(new_role)
        embed = discord.Embed(color=0xADD8E6, description=f"STAFF PROMOTION\n\nStaff Member: {user.mention}\n\nOld Rank: {old_role.mention}\n\nNew Rank: {new_role.mention}\n\nReason: {reason}\n\nIssued by {ctx.author}")
        embed.set_thumbnail(url=THUMBNAIL_URL)
        await ctx.send(embed=embed)
        await log_command(ctx.author, "promote (prefix)", ctx.channel.id, f"promoted {user} from {old_role.id} to {new_role.id}")
    except Exception as e:
        await ctx.send("Error performing promotion. Check bot permissions.")
        await log_command(ctx.author, "promote (prefix) error", ctx.channel.id, str(e))
        log.exception("promote prefix error: %s", e)

@bot.command(name="test")
async def cmd_test(ctx: commands.Context):
    if is_paused and ctx.author.id != MASTER_USER_ID:
        return await ctx.reply("Bot is paused.")
    # cooldown per user
    now = asyncio.get_event_loop().time()
    last = cooldowns.get(ctx.author.id, 0)
    if now - last < COOLDOWN_TEST_SECONDS:
        return await ctx.reply(f"Please wait {int(COOLDOWN_TEST_SECONDS - (now - last))} seconds before using this command again.", ephemeral=True)
    cooldowns[ctx.author.id] = now
    try:
        ch = ctx.guild.get_channel(1377724833881653288) or await ctx.guild.fetch_channel(1377724833881653288)
        if not ch:
            return await ctx.reply("Test channel not found.")
        memberCount = ctx.guild.member_count
        embed = discord.Embed(color=0xADD8E6, description=f"WELCOME!\nWelcome {ctx.author.name} to {ctx.guild.name}! We hope you enjoy your stay here! Check our <#1377719482352402523> for more information!")
        embed.set_thumbnail(url=THUMBNAIL_URL)
        embed.set_image(url=POLL_GIF_URL)
        embed.set_footer(text=f"Member Count: {memberCount}")
        await ch.send(embed=embed)
        await ctx.reply("Test welcome message sent successfully!", ephemeral=True)
        await log_command(ctx.author, "test", ctx.channel.id, f"sent to {ch.id}")
    except Exception as e:
        await ctx.reply("An error occurred while sending the test message.")
        await log_command(ctx.author, "test (error)", ctx.channel.id, str(e))
        log.exception("test cmd error: %s", e)

@bot.command(name="welcometest")
async def cmd_welcometest(ctx: commands.Context):
    if is_paused and ctx.author.id != MASTER_USER_ID:
        return await ctx.reply("Bot is paused.")
    # cooldown handling same as test
    now = asyncio.get_event_loop().time()
    last = cooldowns.get(ctx.author.id, 0)
    if now - last < COOLDOWN_TEST_SECONDS:
        return await ctx.reply(f"Please wait {int(COOLDOWN_TEST_SECONDS - (now - last))} seconds before using this command again.")
    cooldowns[ctx.author.id] = now
    try:
        ch = ctx.guild.get_channel(1377724833881653288) or await ctx.guild.fetch_channel(1377724833881653288)
        if not ch:
            return await ctx.reply("Welcome channel not found.")
        memberCount = ctx.guild.member_count
        embed = discord.Embed(color=0xADD8E6, description=f"WELCOME!\nWelcome {ctx.author.name} to {ctx.guild.name}! We hope you enjoy your stay here! Check our <#1377719482352402523> for more information!")
        embed.set_thumbnail(url=THUMBNAIL_URL)
        embed.set_image(url=POLL_GIF_URL)
        embed.set_footer(text=f"Member Count: {memberCount}")
        await ch.send(embed=embed)
        await ctx.reply("Welcome test message sent successfully!", ephemeral=True)
        await log_command(ctx.author, "welcometest", ctx.channel.id, f"sent to {ch.id}")
    except Exception as e:
        await ctx.reply("An error occurred while sending the welcome test message.")
        await log_command(ctx.author, "welcometest (error)", ctx.channel.id, str(e))
        log.exception("welcometest error: %s", e)

# ---------- Slash Commands (app commands) ----------
# We register on the guild for instant availability
@bot.tree.command(name="promote", description="Promote a staff member")
@app_commands.describe(user="User to promote", old_role="Role to remove", new_role="Role to assign", reason="Reason for promotion")
async def slash_promote(interaction: discord.Interaction, user: discord.Member, old_role: discord.Role, new_role: discord.Role, reason: str):
    if is_paused and interaction.user.id != MASTER_USER_ID:
        return await interaction.response.send_message("Bot is paused.", ephemeral=True)
    if not interaction.user.get_role(PROMOTION_PERMS_ROLE_ID) and PROMOTION_PERMS_ROLE_ID not in [r.id for r in interaction.user.roles]:
        await log_command(interaction.user, "promote (denied)", interaction.channel_id, "missing permission")
        return await interaction.response.send_message("You do not have permission to use this command.", ephemeral=True)
    await interaction.response.defer()
    try:
        member = user
        if old_role.id not in [r.id for r in member.roles]:
            await interaction.followup.send(f"The user does not have the old role <@&{old_role.id}>.")
            return
        await member.remove_roles(old_role)
        await member.add_roles(new_role)
        embed = discord.Embed(color=0xADD8E6, description=f"STAFF PROMOTION\n\nStaff Member: {member.mention}\n\nOld Rank: <@&{old_role.id}>\n\nNew Rank: <@&{new_role.id}>\n\nReason: {reason}\n\nIssued by {interaction.user}")
        embed.set_thumbnail(url=THUMBNAIL_URL)
        await interaction.followup.send(embed=embed)
        await log_command(interaction.user, "promote", interaction.channel_id, f"promoted {member} from {old_role.id} to {new_role.id}")
    except Exception as e:
        await interaction.followup.send("An error occurred while processing the promotion.")
        await log_command(interaction.user, "promote (error)", interaction.channel_id, str(e))
        log.exception("slash promote error: %s", e)

@bot.tree.command(name="stafffeedback", description="Submit feedback for a staff member")
@app_commands.describe(staff="Staff member to review", review="Your review", rating="Rating (e.g., 4 stars)")
async def slash_stafffeedback(interaction: discord.Interaction, staff: discord.Member, review: str, rating: str):
    if is_paused and interaction.user.id != MASTER_USER_ID:
        return await interaction.response.send_message("Bot is paused.", ephemeral=True)
    await interaction.response.defer(ephemeral=True)
    try:
        ch = bot.get_channel(FEEDBACK_CHANNEL_ID) or await bot.fetch_channel(FEEDBACK_CHANNEL_ID)
        if not ch:
            return await interaction.followup.send("Feedback channel not found.", ephemeral=True)
        embed = discord.Embed(color=0xADD8E6, title="Staff Feedback")
        embed.set_thumbnail(url=THUMBNAIL_URL)
        embed.add_field(name="Staff Member", value=f"<@{staff.id}>", inline=True)
        embed.add_field(name="Rating", value=rating, inline=True)
        embed.add_field(name="Review", value=review, inline=False)
        embed.set_footer(text=f"Feedback submitted by {interaction.user}")
        await ch.send(embed=embed)
        await interaction.followup.send("Thank you for your feedback!", ephemeral=True)
        await log_command(interaction.user, "stafffeedback", interaction.channel_id, f"for {staff.id} rating:{rating}")
    except Exception as e:
        await interaction.followup.send("An error occurred while submitting your feedback.", ephemeral=True)
        await log_command(interaction.user, "stafffeedback (error)", interaction.channel_id, str(e))
        log.exception("stafffeedback error: %s", e)

# ---------- SERVER OVERRIDE & UNLOCK (slash) ----------
@bot.tree.command(name="serveroverride", description="Emergency override — remove admin roles and lockdown channels")
@app_commands.describe(reason="Reason (optional)")
async def slash_serveroverride(interaction: discord.Interaction, reason: Optional[str] = None):
    global removed_roles_store, channel_perms_store
    if is_paused and interaction.user.id != MASTER_USER_ID:
        return await interaction.response.send_message("Bot is paused.", ephemeral=True)
    if not isinstance(interaction.user, discord.Member) or ADMIN_OVERRIDE_ROLE_ID not in [r.id for r in interaction.user.roles]:
        await log_command(interaction.user, "serveroverride (denied)", interaction.channel_id, "missing admin override role")
        return await interaction.response.send_message("You do not have permission to use this command.", ephemeral=True)
    await interaction.response.defer()
    reason = reason or "No reason provided"
    guild = interaction.guild
    removed_roles_store = {}
    # 1) remove admin roles from members who do NOT have Admin Override
    removed_count = 0
    members = await guild.fetch_members().flatten()
    for member in members:
        # skip if member has admin override
        if ADMIN_OVERRIDE_ROLE_ID in [r.id for r in member.roles]:
            continue
        removed = []
        for roleid in ADMIN_ROLE_IDS:
            if roleid in [r.id for r in member.roles]:
                try:
                    await member.remove_roles(discord.Object(id=roleid))
                    removed.append(roleid)
                    removed_count += 1
                except Exception as e:
                    log.exception("Failed remove role: %s", e)
        if removed:
            removed_roles_store[member.id] = removed

    # 2) store previous channel perms where @everyone had SendMessages allowed
    channel_perms_store = {}
    for ch in guild.channels:
        try:
            if not isinstance(ch, (discord.TextChannel, discord.Thread)):
                continue
            everyone_perms = ch.permissions_for(guild.default_role)
            if everyone_perms.send_messages:
                # capture existing overwrite states
                prevEveryoneState = "unset"
                prevAdminState = "unset"
                overwrite = ch.overwrites_for(guild.default_role)
                if overwrite.send_messages is True:
                    prevEveryoneState = "allow"
                elif overwrite.send_messages is False:
                    prevEveryoneState = "deny"
                admin_overwrite = ch.overwrites_for(discord.Object(id=ADMIN_OVERRIDE_ROLE_ID))
                if getattr(admin_overwrite, "send_messages", None) is True:
                    prevAdminState = "allow"
                elif getattr(admin_overwrite, "send_messages", None) is False:
                    prevAdminState = "deny"
                channel_perms_store[ch.id] = {"prevEveryoneState": prevEveryoneState, "prevAdminState": prevAdminState}
        except Exception:
            continue

    # 3) send image + message to target override channels
    override_embed = discord.Embed(title="ADMIN OVERRIDE TRIGGERED", color=0xFFCC00, description="All chattable channels will now be placed on lockdown.\n\nPlease be patient while we make things better.")
    override_embed.set_thumbnail(url=THUMBNAIL_URL)
    override_embed.add_field(name="Activated by", value=f"{interaction.user} ({interaction.user.id})", inline=False)
    override_embed.add_field(name="Reason", value=reason or "No reason provided", inline=False)
    override_embed.add_field(name="Admin roles removed (approx)", value=str(removed_count), inline=True)
    override_embed.set_image(url=OVERRIDE_IMAGE_URL)
    override_embed.timestamp = datetime.utcnow()
    for ch_id in OVERRIDE_CHANNEL_IDS:
        try:
            ch = bot.get_channel(ch_id) or await bot.fetch_channel(ch_id)
            if ch and isinstance(ch, discord.TextChannel):
                await ch.send(embed=override_embed)
        except Exception:
            continue

    # 4) Lock recorded channels: set @everyone send_messages false, allow Admin Override send_messages true
    for cid, prev in channel_perms_store.items():
        try:
            ch = bot.get_channel(cid) or await bot.fetch_channel(cid)
            if not ch or not isinstance(ch, discord.TextChannel):
                continue
            await ch.set_permissions(guild.default_role, send_messages=False)
            await ch.set_permissions(discord.Object(id=ADMIN_OVERRIDE_ROLE_ID), send_messages=True)
        except Exception as e:
            log.exception("Failed to edit perms for channel %s: %s", cid, e)

    # 5) Log to log channel & respond
    try:
        logch = bot.get_channel(OVERRIDE_LOG_CHANNEL_ID) or await bot.fetch_channel(OVERRIDE_LOG_CHANNEL_ID)
        if logch:
            log_embed = discord.Embed(title="Server Override Activated", color=0xFF5500)
            log_embed.set_thumbnail(url=THUMBNAIL_URL)
            log_embed.add_field(name="Triggered by", value=f"{interaction.user} ({interaction.user.id})", inline=False)
            log_embed.add_field(name="Reason", value=reason or "No reason provided", inline=False)
            log_embed.add_field(name="Admin roles removed (approx)", value=str(removed_count), inline=True)
            log_embed.add_field(name="Locked channels", value=str(len(channel_perms_store)), inline=True)
            log_embed.timestamp = datetime.utcnow()
            await logch.send(embed=log_embed)
    except Exception:
        pass

    await interaction.followup.send("Emergency override activated. Admin roles removed and channels locked.")
    await log_command(interaction.user, "serveroverride", interaction.channel.id, f"removed roles:{removed_count} locked:{len(channel_perms_store)}")

@bot.tree.command(name="unlockserver", description="Unlock server channels and restore roles after serveroverride")
async def slash_unlockserver(interaction: discord.Interaction):
    global removed_roles_store, channel_perms_store
    if not isinstance(interaction.user, discord.Member) or ADMIN_OVERRIDE_ROLE_ID not in [r.id for r in interaction.user.roles]:
        await log_command(interaction.user, "unlockserver (denied)", interaction.channel_id, "missing ADMIN_OVERRIDE_ROLE_ID")
        return await interaction.response.send_message("You do not have permission to use this command.", ephemeral=True)
    await interaction.response.defer()
    guild = interaction.guild
    # Restore channel perms from channel_perms_store
    for cid, prev in channel_perms_store.items():
        try:
            ch = bot.get_channel(cid) or await bot.fetch_channel(cid)
            if not ch or not isinstance(ch, discord.TextChannel):
                continue
            if prev["prevEveryoneState"] == "allow":
                await ch.set_permissions(guild.default_role, send_messages=True)
            elif prev["prevEveryoneState"] == "deny":
                await ch.set_permissions(guild.default_role, send_messages=False)
            else:
                # remove overwrite
                await ch.set_permissions(guild.default_role, overwrite=None)
            if prev["prevAdminState"] == "allow":
                await ch.set_permissions(discord.Object(id=ADMIN_OVERRIDE_ROLE_ID), send_messages=True)
            elif prev["prevAdminState"] == "deny":
                await ch.set_permissions(discord.Object(id=ADMIN_OVERRIDE_ROLE_ID), send_messages=False)
            else:
                await ch.set_permissions(discord.Object(id=ADMIN_OVERRIDE_ROLE_ID), overwrite=None)
        except Exception as e:
            log.exception("unlockserver channel restore error: %s", e)
    # Restore roles removed
    restored = 0
    for member_id, roles in removed_roles_store.items():
        try:
            member = guild.get_member(member_id) or await guild.fetch_member(member_id)
            for rid in roles:
                try:
                    await member.add_roles(discord.Object(id=rid))
                    restored += 1
                except Exception:
                    continue
        except Exception:
            continue
    # Clear stores
    channel_perms_store = {}
    removed_roles_store = {}
    await interaction.followup.send("Server unlocked and previous permissions restored (where available).")
    await log_command(interaction.user, "unlockserver", interaction.channel.id, f"restored ~{restored} roles")

# ---------- POLLS (basic implementation) ----------
# For simplicity: /poll question duration options as a single string separated by '|' (OR send via prefix)
@bot.tree.command(name="poll", description="Create a poll (options separated by |)")
@app_commands.describe(question="Question", duration="Duration in hours", options="Options, separated by | (2-10)")
async def slash_poll(interaction: discord.Interaction, question: str, duration: int, options: str, title: Optional[str] = None, footer: Optional[str] = None):
    if is_paused and interaction.user.id != MASTER_USER_ID:
        return await interaction.response.send_message("Bot is paused.", ephemeral=True)
    # permission check
    member_roles = [r.id for r in interaction.user.roles] if isinstance(interaction.user, discord.Member) else []
    if SLT_ROLE_ID not in member_roles and STAFF_SHOUT_ROLE_ID not in member_roles:
        await log_command(interaction.user, "poll (denied)", interaction.channel_id, "missing SLT/StaffShout")
        return await interaction.response.send_message("You do not have permission to create polls.", ephemeral=True)

    opts = [o.strip() for o in options.split("|") if o.strip()]
    if len(opts) < 2:
        return await interaction.response.send_message("You must provide at least 2 options (separated by |).", ephemeral=True)
    if len(opts) > 10:
        return await interaction.response.send_message("Maximum 10 options allowed.", ephemeral=True)

    await interaction.response.defer()
    # make embed
    initialDesc = "\n\n".join(f"{i+1}. {opt} — 0 votes" for i, opt in enumerate(opts))
    embed = discord.Embed(title=title or "Poll", description=f"**{question}**\n\n{initialDesc}", color=0xADD8E6)
    embed.set_thumbnail(url=THUMBNAIL_URL)
    embed.set_image(url=POLL_GIF_URL)
    embed.set_footer(text=footer or f"Poll closes in {duration} hour(s)")
    # build buttons
    view = discord.ui.View(timeout=None)
    for i, opt in enumerate(opts):
        async def make_callback(index):
            async def callback(inter: discord.Interaction):
                # voting
                pid = poll_id
                p = active_polls.get(pid)
                if not p or p.get("ended"):
                    return await inter.response.send_message("This poll has ended or does not exist.", ephemeral=True)
                # optional voter role check omitted for simplicity
                uid = inter.user.id
                prev = p["voters"].get(uid)
                if prev is not None and prev == index:
                    return await inter.response.send_message("You have already voted for that option.", ephemeral=True)
                if prev is not None:
                    p["votes"][prev] = max(0, (p["votes"][prev] or 1) - 1)
                p["votes"][index] = (p["votes"][index] or 0) + 1
                p["voters"][uid] = index
                # update message
                liveDesc = "\n\n".join(f"{ii+1}. {o} — {p['votes'][ii] or 0} votes" for ii, o in enumerate(p["options"]))
                new_embed = discord.Embed(title=p["title"] or "Poll", description=f"**{p['question']}**\n\n{liveDesc}", color=0xADD8E6)
                new_embed.set_thumbnail(url=THUMBNAIL_URL)
                new_embed.set_image(url=POLL_GIF_URL)
                new_embed.set_footer(text=p["footer"] or f"Poll closes in {duration} hour(s)")
                try:
                    await p["message"].edit(embed=new_embed)
                except Exception:
                    pass
                await inter.response.send_message(f"You voted for option {index+1}.", ephemeral=True)
            return callback
        btn = discord.ui.Button(label=f"{i+1}. {opt[:75]}", style=discord.ButtonStyle.primary, custom_id=f"poll_{i}")
        btn.callback = await make_callback(i)
        view.add_item(btn)

    # send
    channel = interaction.channel
    sent = await channel.send(embed=embed, view=view)
    # store poll
    poll_id = f"{interaction.id}"
    active_polls[poll_id] = {
        "question": question,
        "title": title,
        "footer": footer,
        "options": opts,
        "votes": [0] * len(opts),
        "voters": {},
        "message": sent,
        "ended": False,
        "expires_at": datetime.utcnow() + timedelta(hours=max(1, duration))
    }

    # schedule auto-close
    async def auto_close(pid):
        await asyncio.sleep(duration * 3600)
        p = active_polls.get(pid)
        if not p:
            return
        p["ended"] = True
        finalDesc = "\n\n".join(f"{i+1}. {opt} — {p['votes'][i] or 0} votes" for i, opt in enumerate(p["options"]))
        finalEmbed = discord.Embed(title=p["title"] or "Poll (Closed)", description=f"**{p['question']}**\n\n{finalDesc}", color=0xADD8E6)
        finalEmbed.set_thumbnail(url=THUMBNAIL_URL)
        finalEmbed.set_image(url=POLL_GIF_URL)
        finalEmbed.set_footer(text=p["footer"] or "Poll ended")
        try:
            await p["message"].edit(embed=finalEmbed, view=None)
        except Exception:
            pass
        active_polls.pop(pid, None)
    bot.loop.create_task(auto_close(poll_id))

    await interaction.followup.send(f"Poll created — Poll ID: {poll_id}", ephemeral=True)
    await log_command(interaction.user, "poll", interaction.channel_id, f"question:{question}")

# ---------- SESSION COMMANDS (slash only, ALT role required, posts only to SESSION_CHANNEL_ID) ----------
@bot.tree.command(name="sessionvote", description="Session Vote (ALT only)")
async def sc_sessionvote(interaction: discord.Interaction):
    await handle_session_cmd(interaction, "vote")

@bot.tree.command(name="ssu", description="Session Start Up (ALT only)")
async def sc_ssu(interaction: discord.Interaction):
    await handle_session_cmd(interaction, "start")

@bot.tree.command(name="ssd", description="Session Shut-Down (ALT only)")
async def sc_ssd(interaction: discord.Interaction):
    await handle_session_cmd(interaction, "shutdown")

@bot.tree.command(name="sessionlow", description="Session Low (ALT only)")
async def sc_sessionlow(interaction: discord.Interaction):
    await handle_session_cmd(interaction, "low")

@bot.tree.command(name="sessionfull", description="Session Full (ALT only)")
async def sc_sessionfull(interaction: discord.Interaction):
    await handle_session_cmd(interaction, "full")

async def handle_session_cmd(interaction: discord.Interaction, kind: str):
    if is_paused and interaction.user.id != MASTER_USER_ID:
        return await interaction.response.send_message("Bot is paused.", ephemeral=True)
    # Only ALT role allowed (use ALT_ROLE_LOCK as requested)
    member = interaction.user if isinstance(interaction.user, discord.Member) else None
    if not member:
        return await interaction.response.send_message("Session commands can only be used in guilds.", ephemeral=True)
    if ALT_ROLE_LOCK not in [r.id for r in member.roles]:
        await log_command(interaction.user, f"session {kind} (denied)", interaction.channel_id, "missing ALT role")
        return await interaction.response.send_message("You do not have permission to use this command. (ALT only)", ephemeral=True)

    embeds = make_session_embeds(member.display_avatar.url, member.display_name)
    target_channel = bot.get_channel(SESSION_CHANNEL_ID) or await bot.fetch_channel(SESSION_CHANNEL_ID)
    if not target_channel:
        await interaction.response.send_message("Session channel not found.", ephemeral=True)
        return
    try:
        await target_channel.send(embed=embeds[kind])
        await interaction.response.send_message(f"Session {kind} posted to <#{SESSION_CHANNEL_ID}>.", ephemeral=True)
        await log_command(interaction.user, f"session_{kind}", interaction.channel_id, f"posted to {SESSION_CHANNEL_ID}")
    except Exception as e:
        await interaction.response.send_message("Failed to post session embed.", ephemeral=True)
        await log_command(interaction.user, f"session_{kind} (error)", interaction.channel_id, str(e))
        log.exception("session cmd error: %s", e)

# ---------- UPTIME PINGER (ping rails/hosting every 5 minutes) ----------
@tasks.loop(minutes=5.0)
async def uptime_ping():
    # default to http://localhost:3000/ if not set (common)
    url = os.environ.get("UPTIME_URL", "http://localhost:3000/")
    try:
        async with aiohttp.ClientSession() as s:
            async with s.get(url, timeout=10) as resp:
                log.info(f"Uptime ping status: {resp.status}")
    except Exception as e:
        log.warning("Uptime ping failed: %s", e)

# ---------- Run ----------
if __name__ == "__main__":
    try:
        bot.run(TOKEN)
    except Exception as e:
        log.exception("Fatal error running bot: %s", e)
        raise
